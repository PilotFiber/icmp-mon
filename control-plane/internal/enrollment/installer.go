package enrollment

import (
	"context"
	"fmt"
	"strings"
	"text/template"
	"time"
)

// AgentConfig holds configuration for the agent.
type AgentConfig struct {
	ControlPlaneURL string
	AgentName       string
	Region          string
	Location        string
	Provider        string
	Tags            map[string]string
}

// InstallPaths contains paths for agent installation.
type InstallPaths struct {
	BinaryDir   string // /usr/local/bin
	ConfigDir   string // /etc/icmpmon
	DataDir     string // /var/lib/icmpmon
	LogDir      string // /var/log/icmpmon
	ServiceFile string // /etc/systemd/system/icmpmon-agent.service
	ConfigFile  string // /etc/icmpmon/agent.yaml
	BinaryPath  string // /usr/local/bin/icmpmon-agent
}

// DefaultPaths returns default installation paths.
func DefaultPaths() InstallPaths {
	return InstallPaths{
		BinaryDir:   "/usr/local/bin",
		ConfigDir:   "/etc/icmpmon",
		DataDir:     "/var/lib/icmpmon",
		LogDir:      "/var/log/icmpmon",
		ServiceFile: "/etc/systemd/system/icmpmon-agent.service",
		ConfigFile:  "/etc/icmpmon/agent.yaml",
		BinaryPath:  "/usr/local/bin/icmpmon-agent",
	}
}

// CreateAgentUser creates the icmpmon system user.
func CreateAgentUser(ctx context.Context, ssh *SSHClient) error {
	// Check if user already exists
	_, err := ssh.Run(ctx, "id icmpmon")
	if err == nil {
		return nil // User already exists
	}

	// Create system user (no login shell, no home directory)
	_, err = ssh.RunWithSudo(ctx, "useradd -r -s /bin/false icmpmon")
	if err != nil && !strings.Contains(err.Error(), "already exists") {
		return fmt.Errorf("creating icmpmon user: %w", err)
	}

	return nil
}

// CreateDirectories creates the necessary directories for the agent.
func CreateDirectories(ctx context.Context, ssh *SSHClient, paths InstallPaths) error {
	dirs := []string{paths.ConfigDir, paths.DataDir, paths.LogDir}

	for _, dir := range dirs {
		_, err := ssh.RunWithSudo(ctx, fmt.Sprintf("mkdir -p %s", dir))
		if err != nil {
			return fmt.Errorf("creating directory %s: %w", dir, err)
		}

		// Set ownership to icmpmon user
		_, err = ssh.RunWithSudo(ctx, fmt.Sprintf("chown icmpmon:icmpmon %s", dir))
		if err != nil {
			return fmt.Errorf("setting ownership on %s: %w", dir, err)
		}
	}

	return nil
}

// DownloadAgentBinary downloads the agent binary from the control plane.
func DownloadAgentBinary(ctx context.Context, ssh *SSHClient, controlPlaneURL, platform string, paths InstallPaths) error {
	// Build download URL
	downloadURL := fmt.Sprintf("%s/api/v1/packages/agent-%s", controlPlaneURL, platform)

	// Download to temp location
	tmpPath := fmt.Sprintf("/tmp/icmpmon-agent-%d", time.Now().UnixNano())

	_, err := ssh.Run(ctx, fmt.Sprintf(
		"curl -fsSL -o %s '%s' || wget -q -O %s '%s'",
		tmpPath, downloadURL, tmpPath, downloadURL))
	if err != nil {
		return fmt.Errorf("downloading agent binary: %w", err)
	}

	// Move to final location with sudo
	_, err = ssh.RunWithSudo(ctx, fmt.Sprintf("mv %s %s", tmpPath, paths.BinaryPath))
	if err != nil {
		return fmt.Errorf("moving binary to %s: %w", paths.BinaryPath, err)
	}

	// Set permissions
	_, err = ssh.RunWithSudo(ctx, fmt.Sprintf("chmod 755 %s", paths.BinaryPath))
	if err != nil {
		return fmt.Errorf("setting binary permissions: %w", err)
	}

	// Set capability for raw sockets (required for ICMP)
	_, err = ssh.RunWithSudo(ctx, fmt.Sprintf("setcap cap_net_raw=ep %s", paths.BinaryPath))
	if err != nil {
		// setcap might not be available, try setting SUID instead
		_, err2 := ssh.RunWithSudo(ctx, fmt.Sprintf("chmod u+s %s", paths.BinaryPath))
		if err2 != nil {
			return fmt.Errorf("setting capabilities: %w (setcap: %v)", err2, err)
		}
	}

	return nil
}

// WriteAgentConfig writes the agent configuration file.
func WriteAgentConfig(ctx context.Context, ssh *SSHClient, cfg AgentConfig, paths InstallPaths) error {
	// Build config content
	config := generateAgentConfig(cfg)

	// Write config file
	if err := ssh.WriteFileWithSudo(ctx, paths.ConfigFile, []byte(config), "0640"); err != nil {
		return fmt.Errorf("writing config file: %w", err)
	}

	// Set ownership
	_, err := ssh.RunWithSudo(ctx, fmt.Sprintf("chown icmpmon:icmpmon %s", paths.ConfigFile))
	if err != nil {
		return fmt.Errorf("setting config ownership: %w", err)
	}

	return nil
}

// generateAgentConfig generates the agent YAML configuration.
func generateAgentConfig(cfg AgentConfig) string {
	tmpl := `# ICMP-Mon Agent Configuration
# Generated by enrollment service

control_plane:
  url: {{ .ControlPlaneURL }}

agent:
  name: {{ .AgentName }}
{{- if .Region }}
  region: {{ .Region }}
{{- end }}
{{- if .Location }}
  location: {{ .Location }}
{{- end }}
{{- if .Provider }}
  provider: {{ .Provider }}
{{- end }}
{{- if .Tags }}
  tags:
{{- range $key, $value := .Tags }}
    {{ $key }}: "{{ $value }}"
{{- end }}
{{- end }}

# Logging
logging:
  level: info
  format: json
`

	t, _ := template.New("config").Parse(tmpl)
	var buf strings.Builder
	t.Execute(&buf, cfg)
	return buf.String()
}

// InstallSystemdService creates and enables the systemd service.
func InstallSystemdService(ctx context.Context, ssh *SSHClient, paths InstallPaths) error {
	service := generateSystemdService(paths)

	// Write service file
	if err := ssh.WriteFileWithSudo(ctx, paths.ServiceFile, []byte(service), "0644"); err != nil {
		return fmt.Errorf("writing service file: %w", err)
	}

	// Reload systemd
	_, err := ssh.RunWithSudo(ctx, "systemctl daemon-reload")
	if err != nil {
		return fmt.Errorf("reloading systemd: %w", err)
	}

	// Enable service
	_, err = ssh.RunWithSudo(ctx, "systemctl enable icmpmon-agent")
	if err != nil {
		return fmt.Errorf("enabling service: %w", err)
	}

	return nil
}

// generateSystemdService generates the systemd service unit file.
func generateSystemdService(paths InstallPaths) string {
	return fmt.Sprintf(`[Unit]
Description=ICMP-Mon Agent
Documentation=https://github.com/pilot-net/icmp-mon
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=icmpmon
Group=icmpmon
ExecStart=%s --config %s
Restart=always
RestartSec=5
StandardOutput=journal
StandardError=journal
SyslogIdentifier=icmpmon-agent

# Security hardening
NoNewPrivileges=yes
ProtectSystem=strict
ProtectHome=yes
PrivateTmp=yes
PrivateDevices=yes
ProtectKernelTunables=yes
ProtectControlGroups=yes
RestrictSUIDSGID=yes
RestrictNamespaces=yes

# Allow network raw sockets for ICMP
AmbientCapabilities=CAP_NET_RAW

# Writable directories
ReadWritePaths=%s %s

[Install]
WantedBy=multi-user.target
`, paths.BinaryPath, paths.ConfigFile, paths.DataDir, paths.LogDir)
}

// StartAgent starts the agent service.
func StartAgent(ctx context.Context, ssh *SSHClient) error {
	_, err := ssh.RunWithSudo(ctx, "systemctl start icmpmon-agent")
	if err != nil {
		return fmt.Errorf("starting agent: %w", err)
	}

	// Wait a moment and check status
	time.Sleep(2 * time.Second)

	_, err = ssh.RunWithSudo(ctx, "systemctl is-active icmpmon-agent")
	if err != nil {
		// Get logs for debugging
		logs, _ := ssh.RunWithSudo(ctx, "journalctl -u icmpmon-agent -n 20 --no-pager")
		return fmt.Errorf("agent failed to start: %w\nLogs:\n%s", err, logs)
	}

	return nil
}

// StopAgent stops the agent service.
func StopAgent(ctx context.Context, ssh *SSHClient) error {
	_, err := ssh.RunWithSudo(ctx, "systemctl stop icmpmon-agent")
	return err
}

// GetAgentStatus returns the agent service status.
func GetAgentStatus(ctx context.Context, ssh *SSHClient) (string, error) {
	output, err := ssh.RunWithSudo(ctx, "systemctl status icmpmon-agent --no-pager")
	if err != nil {
		// Non-zero exit doesn't always mean error for status
		return output, nil
	}
	return output, nil
}

// GetAgentLogs returns recent agent logs.
func GetAgentLogs(ctx context.Context, ssh *SSHClient, lines int) (string, error) {
	return ssh.RunWithSudo(ctx, fmt.Sprintf("journalctl -u icmpmon-agent -n %d --no-pager", lines))
}

// VerifyBinaryChecksum verifies the downloaded binary against a checksum.
func VerifyBinaryChecksum(ctx context.Context, ssh *SSHClient, path, expectedChecksum string) error {
	output, err := ssh.Run(ctx, fmt.Sprintf("sha256sum %s | cut -d' ' -f1", path))
	if err != nil {
		return fmt.Errorf("calculating checksum: %w", err)
	}

	actualChecksum := strings.TrimSpace(output)
	if actualChecksum != expectedChecksum {
		return fmt.Errorf("checksum mismatch: expected %s, got %s", expectedChecksum, actualChecksum)
	}

	return nil
}
